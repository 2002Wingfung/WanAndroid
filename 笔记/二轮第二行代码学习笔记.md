# 二轮笔记

## 第9章 使用网络技术

### 9.1 WebView的用法

```java
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        WebView webView=findViewById(R.id.web_view);
        webView.getSettings().setJavaScriptEnabled(true);
        webView.getSettings().setDomStorageEnabled(true);
        webView.setWebViewClient(new WebViewClient());
        webView.loadUrl("https://www.baidu.com");
    }
}
```

activity_main.xml中：

```xml
<WebView
    android:id="@+id/web_view"
    android:layout_width="match_parent"
    android:layout_height="match_parent"/>
```

首先使用findViewById()方法获取到了 WebView 的实例，然后调用 WebView的getSettings()方法可以去设置一些浏览器的属性，调用了 setJavaScriptEnabled()方法来让 WebView 支持JavaScript脚本。

我们调用了 WebView的 setWebViewClient()方法，并传人了一个 WebViewClient的实例。这段代码的作用是，当需要从一个网页跳转到另一个网页时我们希望目标网页仍然在当前 WebView 中显示，而不是打开系统浏览器。

调用 WebView的 loadUrL()方法，并将网址传入，即可展示相应网页的内容

注意，由于本程序使用到了网络功能，而访问网络是需要声明权限的，因此我们还得修改AndroidManifest.xml文件，并加入权限声明。

```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">
    <uses-permission android:name="android.permission.INTERNET"/>
    <application>
        
    </application>

</manifest>
```

---

## 9.4 解析json格式

**报错**：`System.err: java.io.IOException: Cleartext HTTP traffic to img95.699pic.com not permitted`

报错大致意思就是：网址的请求不被允许。

Android 9.0是默认禁止所有http请求的，需要在Manifest.xml的application标签中设置如以下代码才可以正常进行网络请求:

```xml
android:usesCleartextTraffic="true"
```

---

## 9.5 实践

HttpConnection工具类

```java
public class HttpUtil {
    public static void sendHttpRequest(final String address,final HttpCallbackListener listener){
        new Thread(new Runnable() {
            @Override
            public void run() {
                HttpURLConnection connection=null;
                BufferedReader reader=null;
                try {
                    URL url=new URL(address);
                    connection=(HttpURLConnection) url.openConnection();
                    connection.setRequestMethod("GET");
                    connection.setConnectTimeout(8000);
                    connection.setReadTimeout(8000);
//                    connection.setDoInput(true);
//                    connection.setDoOutput(true);
                    InputStream in=connection.getInputStream();
                    reader=new BufferedReader(new InputStreamReader(in));
                    StringBuilder response=new StringBuilder();
                    String line;
                    while ((line=reader.readLine())!=null){
                        response.append(line);
                    }
                    if (listener!=null){
                        //回调onFinish()方法
                        listener.onFinish(response.toString());
                    }
                } catch (Exception e) {
                    if (listener!=null){
                        //回调onError()方法
                        listener.onError(e);
                    }
                }finally {
                    if (reader!=null&&listener!=null){
                        try {
                            reader.close();
                        }catch (IOException e){
                            listener.onError(e);
                        }
                    }
                    if (connection!=null){
                        connection.disconnect();
                    }
                }
            }
        }).start();
    }
}

```

以后每当需要发起一条HTTP请求的时候就可以这样写:

```java
String address ="http://www.baidu.com";
String response = HttpUtil.sendHttpRequest(address);
```

在获取到服务器响应的数据后，我们就可以对它进行解析和处理了。但是需要注意，网络请求通常都是属于耗时操作，而 sendHttpRequest()方法的内部并没有开启线程，这样就有可能导致在调用 sendHttpRequest()方法的时候使得主线程被阻塞住。

你可能会说，很简单嘛，在 sendHttpRequest()方法内部开启一个线程不就解决这个问题了吗?其实没有你想象中的那么容易，因为如果我们在 sendHttpRequest()方法中开启了一个线程来发起 HTTP 请求，那么服务器响应的数据是无法进行返回的，所有的耗时逻辑都是在子线程里进行的，sendHttpRequest()方法会在服务器还没来得及响应的时候就执行结束了，当然也就无法返回响应的数据了。**上文解析json的代码中是直接输出日志，并没有进行数据的返回。**

那么遇到这种情况时应该怎么办呢?其实解决方法并不难，只需要使用Java的回调机制就可以了

首先需要定义一个接口，比如将它命名成HttpCallbackListener

```java
public interface HttpCallbackListener {
    void onFinish(String response);
    void onError(Exception e);
}
```

可以看到，我们在接口中定义了两个方法，onFinish()方法表示当服务器成功响应我们请求的时候调用，onError()表示当进行网络操作出现错误的时候调用。这两个方法都带有参数.onFinish()方法中的参数代表着服务器返回的数据，而 onError()方法中的参数记录着错误的详细信息。
接着修改 HttpUtil 中的代码.

我们首先给 sendHttpRequest()方法添加了一个HttpCallbackListener 参数，并在方法的内部开启了一个子线程，然后在子线程里去执行具体的网络操作。注意，子线程中是无法通过return 语句来返回数据的，因此这里我们将服务器响应的数据传入了 HttpCallbackListener 的onFinish()方法中，如果出现了异常就将异常原因传人到 onError()方法中.

现在 sendHttpRequest()方法接收两个参数了，因此我们在调用它的时候还需要将HttpCallbackListener的实例传入。

```java
@Override
public void onClick(View v) {
    if (v.getId()==R.id.send_request){
        //sendRequestWithHttpURLConnection();
        String address="http://10.0.2.2/get_data.json";
        HttpUtil.sendHttpRequest(address, new HttpCallbackListener() {
            @Override
            public void onFinish(String response) {
                responseText.setText(response);
            }

            @Override
            public void onError(Exception e) {

            }
        });
    }
}
```

这样的话，当服务器成功响应的时候，我们就可以在 onFinish()方法里对响应数据进行处理了。类似地，如果出现了异常，就可以在 onError)方法里对异常情况进行处理。如此一来，当服务器成功响应的时候，我们就可以在 onFinish()方法里对响应数据进行处理了。类似地，如果出现了异常，就可以在 onError()方法里对异常情况进行处理。如此一来，我们就巧妙地利用回调机制将响应数据成功返回给调用方了。

---

## 10.2 Android多线程编程

### 10.2.1 线程的基本用法

Android多线程编程其实并不比Java 多线程编程特珠，基本都是使用相同的语法。比如说定义一个线程只需要新建一个类继承自 Thread，然后重写父类的 run()方法，并在里面编写耗时逻辑即可.

```java
class MyThread extends Thread{
    @Override
    public void run (){
        //处理具体的逻辑
    }
}
//那么该如何启动这个线程呢?其实也很简单，只需要 new出MyThread 的实例然后调用它的 start()方法，这样 run()方法中的代码就会在子线程当中运行了，
new MyThread().start();
```

当然，使用继承的方式耦合性有点高，更多的时候我们都会选择使用实现 Runnable 接口的方式来定义一个线程,如下所示:

```java
class MyThread implements Runnable{
    @Override
    public void run (){
        //处理具体的逻辑
    }
}
//如果使用了这种写法，启动线程的方法也需要进行相应的改变，如下所示:
MyThread myThread=new MyThread();
new Thread(myThread).start();
```

可以看到,Thread 的构造函数接收一个 Runnable 参数而我们new出的 MyThread 正是一个实现了 Runnable 接口的对象，所以可以直接将它传人到 Thread 的构造函数里。接着调用Thread的 start()方法，run()方法中的代码就会在子线程当中运行了.

如果你不想专门再定义一个类去实现 Runnable 接口，也可以使用匿名类的方式，这种写法更为常见，如下所示:

```java
new Thread(new Runnable(){
    @Override
    public void run (){
        //处理具体的逻辑
    }
}).start();
```

---

### 10.2.2 在子线程中更新UI

和许多其他的 GUI库一样，Android 的 UI也是线程不安全的。也就是说，如果想要更新应用程序里的UI元素，则必须在主线程中进行，否则就会出现异常

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener{

    private TextView text;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        text=findViewById(R.id.hello);
        Button change=findViewById(R.id.change);
        change.setOnClickListener(this);
    }

    @Override
    public void onClick(View v) {
        switch (v.getId()){
            case R.id.change:
                new Thread(new Runnable() {
                    @Override
                    public void run() {
                        text.setText("Nice to meet you");
                    }
                }).start();
                break;
            default:
                break;
        }
    }
}
```

布局文件中定义了两个控件，TextView 用于在屏幕的正中央显示一个 Hello world 字符串。Button用于改变 TextView中显示的内容，我们希望在点击 Button后可以把TextView中显示的字符串改成Nice to meet you。

可以看到，我们在 Change Text按钮的点击事件里面开启了一个子线程，然后在子线程中调用TextView的setText()方法将显示的字符串改成Nice to meet you。代码的逻辑非常简单，只不过我们是在子线程中更新UI的。现在运行一下程序，并点击 Change按钮，你会发现程序果然崩溃了，异常：`    android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.`

由此证实了 Android 确实是不允许在子线程中进行 UI操作的。但是有些时候，我们必须在子线程里去执行一些耗时任务，然后根据任务的执行结果来更新相应的 UI 控件，这该如何是好呢?

对于这种情况，Android 提供了一套异步消息处理机制，完美地解决了在子线程中进行 UI操作的问题。本小节中我们先来学习一下异步消息处理的使用方法，

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener{

    public static final int UPDATE_TEXT=1;
    private Handler handler=new Handler(){
        public void handleMessage(Message msg){
            switch (msg.what){
                case UPDATE_TEXT:
                    //在这里可以进行UI操作
                    text.setText("Nice to meet you");
                    break;
                default:
                    break;
            }
        }
    };
    private TextView text;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        text=findViewById(R.id.hello);
        Button change=findViewById(R.id.change);
        change.setOnClickListener(this);
    }

    @Override
    public void onClick(View v) {
        switch (v.getId()){
            case R.id.change:
                new Thread(new Runnable() {
                    @Override
                    public void run() {
                        Message message=new Message();
                        message.what=UPDATE_TEXT;
                        handler.sendMessage(message);
                        //将Message对象发送出去
                    }
                }).start();
                break;
            default:
                break;
        }
    }
}
```

这里我们先是定义了一个整型常量 UPDATE_TEXT，用于表示更新 TextView这个动作。然后新增一个Handler 对象，并重写父类的 handleMessage()方法，在这里对具体的 Message进行处理。如果发现 Message的 what 字段的值等于 UPDATE_TEXT，就将 TextView 显示的内容改成
Nice to meet you.

下面再来看一下 Change按钮的点击事件中的代码。可以看到，这次我们并没有在子线程里直接进行UI操作,而是创建了一个Message(android.os.Message)对象,并将它的 what字段的值指定为 UPDATE_TEXT，然后调用Handler 的 sendMessage()方法将这条 Message发送出去。很快，Handler就会收到这条 Message，并在 handleMessage()方法中对它进行处理。注意此时 handleMessage()方法中的代码就是在主线程当中运行的了，所以我们可以放心地在这里进行 UI操作。接下来对 Message携带的 what 字段的值进行判断，如果等于UPDATE_TEXT就将TextView显示的内容改成Nice to meet you。

现在重新运行程序，可以看到屏幕的正中央显示着 Hello world。然后点击一下 Change按钮，显示的内容就被替换成 Nice to meet you，

使用Android 异步消息处理这种机制就可以出色地解决掉在子线程中更新 UI的问题。

### 10.2.3 解析异步消息处理机制

Android中的异步消息处理主要由4个部分组成:Message Handler、MessageQueue和 Looper.

* 1.Message

  Message是在线程之间传递的消息，它可以在内部携带少量的信息，用于在不同线程之间交换数据。上一小节中我们使用到了 Message的 what 字段，除此之外还可以使用arg1和arg2字段来携带一些整型数据，使用 obj 字段携带一个 object 对象

* 2.Handler

  Handler 顾名思义也就是处理者的意思，它主要是用于发送和处理消息的。发送消息一般是使用 Handler 的 sendMessage()方法，而发出的消息经过一系列地辗转处理后，最终会传递到Handler的 handleMessage()方法中。

* 3.MessageQueue

  MessageQueue 是消息队列的意思，它主要用于存放所有通过 Handler 发送的消息。这部分消息会一直存在于消息队列中，等待被处理。每个线程中只会有一个MessageQueue 对象

* 4.Looper

  Looper是每个线程中的 MessageQueue 的管家，调用 Looper 的 **loop**()方法后，就会进入到一个**无限循环**当中，然后每当发现 MessageQueue 中存在一条消息，就会将它取出，并传递到Handler的 handleMessage()方法中。每个线程中也只会有一个 Looper 对象

**异步消息处理的整个流程:**

* 首先需要在主线程当中创建一个 Handler 对象，并重写handleMessaqe()方法。
* 然后当子线程中需要进行UI操作时，就创建一个Message 对象，并通过Handler将这条消息发送出去。
* 之后这条消息会被添加到 MessageQueue 的队列中等待被处理.
* 而 Looper 则会一直尝试从 MessageQueue 中取出待处理消息，最后分发回 Handler 的handleMessage()方法中。
* 由于 Handler 是在主线程中创建的，所以此时 handleMessage()方法中的代码也会在主线程中运行，于是我们在这里就可以安心地进行 UI操作了。

整个异步消息处理机制的流程示意图

![picture/异步消息处理机制流程示意图.png · 洪永峰/Picture - 码云 - 开源中国 (gitee.com)](https://gitee.com/hongyongfeng/picture/raw/master/picture/异步消息处理机制流程示意图.png)

一条Message经过这样一个流程的辗转调用后，也就从子线程进入到了主线程，从不能更新UI变成了可以更新 UI，整个异步消息处理的核心思想也就是如此。而我们在9.2.1小节中使用到的 runOnUiThread()方法其实就是一个异步消息处理机制的接口封装，它虽然表面上看起来用法更为简单，但其实背后的实现原理和上图中的描述是一模一样的。

---

### 10.2.4 使用AsyncTask

不过为了更加方便我们在子线程中对UI进行操作，Android还提供了另外一些好用的工具比如AsyncTask。借助 AsyncTask，即使你对异步消息处理机制完全不了解，也可以十分简单地从子线程切换到主线程。当然，AsyncTask 背后的实现原理也是基于异步消息处理机制的，只是Android 帮我们做了很好的封装而已。

首先来看一下AsyncTask的基本用法，由于AsyncTask 是一个抽象类，所以如果我们想使用它，就必须要创建一个子类去继承它。在继承时我们可以为 AsyncTask 类指定3个泛型参数，这3个参数的用途如下。

* Params。在执行AsyncTask时需要传人的参数，可用于在后台任务中使用。

* Progress。后台任务执行时，如果需要在界面上显示当前的进度，则使用这里指定的泛型作为进度单位。

* Result。当任务执行完毕后，如果需要对结果进行返回，则使用这里指定的泛型作为返回值类型。因此，一个最简单的自定义 AsyncTask 就可以写成如下方式：

  ```java
  class DownloadTask extends AsyncTask<Void, Integer, Boolean>{
      //....
  }
  ```

  

这里我们把AsyncTask的第一个泛型参数指定为 Void，表示在执行 AsyncTask 的时候不需要传人参数给后台任务。第二个泛型参数指定为Integer，表示使用整型数据来作为进度显示单位。第三个泛型参数指定为 Boolean，则表示使用布尔型数据来反馈执行结果。

当然，目前我们自定义的 DownloadTask 还是一个空任务，并不能进行任何实际的操作，我们还需要去重写AsyncTask中的几个方法才能完成对任务的定制。经常需要去重写的方法有以下4个:

* 1.onPreExecute()

  这个方法会在后台任务开始执行之前调用，用于进行一些界面上的初始化操作，比如显示一个进度条对话框等。

* 2.doInBackground(Params...)

  这个方法中的所有代码都会在子线程中运行，我们应该在这里去处理所有的耗时任务。任务一旦完成就可以通过 return 语句来将任务的执行结果返回，如果 AsyncTask 的第三个泛型参数指定的是 Void，就可以不返回任务执行结果。注意，在这个方法中是不可以进行 UI操作的，如果需要更新 UI 元素，比如说反馈当前任务的执行进度，可以调用 publishProgress(Progress...)方法来完成。

* 3.onProgressUpdate(Progress...)

  当在后台任务中调用了 publishProgress(Progress...)方法后，onProgressUpdate(Progress...)方法就会很快被调用，该方法中携带的参数就是在后台任务中传递过来的。在这个方法中可以对 UI进行操作，利用参数中的数值就可以对界面元素进行相应的更新

* 4.onPostExecute(Result)

  当后台任务执行完毕并通过 return 语句进行返回时，这个方法就很快会被调用。返回的数据会作为参数传递到此方法中，可以利用返回的数据来进行一些 UI操作，比如说提醒任务执行的结果，以及关闭掉进度条对话框等。

一个比较完整的AsyncTask：

在这个 DownloadTask 中，我们在 doInBackground()方法里去执行具体的下载任务。这个方法里的代码都是在子线程中运行的，因而不会影响到主线程的运行。注意这里虚构了一个doDownload()方法，这个方法用于计算当前的下载进度并返回，我们假设这个方法已经存在了在得到了当前的下载进度后，下面就该考虑如何把它显示到界面上了，由于 doInBackground()方法是在子线程中运行的,在这里肯定不能进行U操作,所以我们可以调用**publishProgress()方法**并将当前的下载进度传进来，这样onProgressUpdate()方法就会很快被调用，在这里就可以进行 UI操作了。

当下载完成后，doInBackground()方法会返回一个布尔型变量，这样 onPostExecute()方法就会很快被调用，这个方法也是在主线程中运行的。然后在这里我们会根据下载的结果来弹出相应的Toast提示，从而完成整个 DownloadTask任务。
简单来说，使用AsyncTask的诀窍就是,**在 doInBackground()方法中执行具体的耗时任务**，**在onProgressUpdate()方法中进行UI操作,在onPostExecute()方法中执行一些任务的收尾工作**。
如果想要启动这个任务，只需编写以下代码即可:

`new DownloadTask().execute();`

以上就是 AsyncTask 的基本用法.我们并不需要去考虑什么异步消息处理机制，也不需要专门使用一个 Handler 来发送和接收消息，只需要调用一下publishProgress()方法，就可以轻松地从子线程切换到UI线程了。

## 10.3服务的基本用法

了解了Android 多线程编程的技术之后，下面就让我们进入到本章的正题，开始对服务的相关内容进行学习。作为Android 四大组件之一，服务也少不了有很多非常重要的知识点，那我们自然要从最基本的用法开始学习了。

### 10.3.1 定义一个服务

首先看一下如何在项目中定义一个服务。新建一个 ServiceTest项目，然后右击 comexample.
servicetestNew-ServiceService，

---

## 目前学完了10.3.2



---

## 13.1 全局获取Context的技巧

回想这么久以来我们所学的内容，你会发现有很多地方都需要用到 Context,弹出Toast的时候需要，启动活动的时候需要，发送广播的时候需要，操作数据库的时候需要，使用通知的时候需要，等等等等。

或许目前你还没有为得不到 context 而发愁过，因为我们很多的操作都是在活动中进行的而活动本身就是一个 Context 对象。但是，当应用程序的架构逐渐开始复杂起来的时候，很多的逻辑代码都将脱离Activity 类，但此时你又恰恰需要使用Context，也许这个时候你就会感到有些伤脑筋了。

举个例子来说吧，在第9章的最佳实践环节，我们编写了一个 Httputil类，在这里将一些通用的网络操作封装了起来，

上文使用的 sendHttpRequest()方法来发送 HTTP 请求显然是没有问题的，并且我们还可以在回调方法中处理服务器返回的数据。但现在我们想对 sendHttpRequest()方法进行一些优化。当检测到网络不存在的时候就给用户一个 Toast 提示，并且不再执行后面的代码。看似一个挺简单的功能，可是却存在一个让人头疼的问题，弹出 Toast提示需要一个 Context 参数，而我们在HttpUtil类中显然是获取不到 Context 对象的，这该怎么办呢?

其实要想快速解决这个问题也很简单，大不了在 sendHttpRequest()方法中添加一个Context 参数就行了嘛，可以看到,这里在方法中添加了一个Context 参数并且**假设**有一个isNetworkAvailable(方法用于判断当前网络是否可用，如果网络不可用的话就弹出Toast 提示，并将方法return掉。

虽说这也确实是一种解决方案，但是却有点推卸责任的嫌疑，因为我们将获取 Context 的任务转移给了 sendHttpRequest()方法的调用方，至于调用方能不能得到 Context 对象，那就不是我们需要考虑的问题了。

由此可以看出，在某些情况下，获取 Context 并非是那么容易的一件事，有时候还是挺伤脑筋的。不过别担心，下面我们就来学习一种技巧，让你在项目的任何地方都能够轻松获取到Context。

Android提供了一个Application 类，每当应用程序启动的时候，系统就会自动将这个类进行初始化。而我们可以定制一个自己的 Application 类，以便于管理程序内一些全局的状态信息，比如说全局 Context。

定制一个自己的Application 其实并不复杂,首先我们需要创建一个MyApplication 类继承自Application，

```java
public class MyApplication extends Application {
    private static Context context;

    @Override
    public void onCreate() {
        super.onCreate();
        context = getApplicationContext();
    }
    public static Context getContext(){
        return context;
    }
}
```

可以看到，MyApplication 中的代码非常简单。这里我们重写了父类的 onCreate()方法并通过调用getApplicationContext()方法得到了一个应用程序级别的 Context，然后又提供了一个静态的 getContext()方法，在这里将刚才获取到的 Context 进行返回。

接下来我们需要告知系统，当程序启动的时候应该初始化 MyApplication 类，而不是默认的Application类。这一步也很简单，在AndroidManifestxml文件的<application>标签下进行指定就可以了，代码如下所示:

在manifest.xml的application标签下加入属性：

`android:name=".MyApplication"`,最好写完整的包名.类名

这样我们就已经实现了一种全局获取 Context 的机制，之后不管你想在项目的任何地方使用 Context，只需要调用一下 MyApplication.getContext()就可以了。

例如：

```java
Toast.makeText(MyApplication.getContext()，"network is unavailable",Toast.LENGTH.SHORT).show();
```

总而言之，一些需要context的方法不需要再通过传参的方式来得到 Context 对象，而是调用一下 MyApplication.getContext()方法就可以了。有了这个技巧，你再也不用为得不到Context 对象而发愁了。

**注意：任何一个项目都只能配置一个Application。**

---

## 13.2 使用Intent传递参数

### 13.2.1 Serializable 方式

使用Intent来传递对象通常有两种实现方式:Serializable和Parelablc,本小节巾我们先学习一下第一种实现方式。

Serializable 是序列化的意思，表示将一个对象转换成可存储或可传输的状态。序列化后的对象可以在网络上进行传输，也可以存储到本地。至于序列化的方法也很简单，只需要让一个类去实现 Serializable 这个接口就可以了。
比如说有一个 Person 类，其中包含了 name 和age 这两个字段，想要将它序列化就可以这样写：

```java
public class Person implements Serializable{
    //成员变量
    //成员方法
}
```

然后就可以直接将Person对象当作参数传入Intent中了,一定要实现Serializable接口，否则在传入Person对象的时候会报错。

```java
//在Activity中
Person person=new Person();
person.setAge(20);
person.setName("jim");
Intent intent=new Intent(FirstActivity.this,SecondActivity.class);
intent.putExtra("person_data",person);
startActivity(intent);
```

在 SecondActivity 中获取这个对象也很简单，写法如下:

`Person person = (Person) getIntent(). getSerializableExtra("person_data");`

这里调用了 getSerializableExtra()方法来获取通过参数传递过来的序列化对象,接着**再将它向下转型成Person 对象**，这样我们就成功实现了使用Intent来传递对象的功能了

**缺点**：一些**含有内部类，内部接口的类**使用该接口传递对象时会发生错误，导致接收到的对象的地址值和原来传递的对象参数的地址值不相等，导致不能获取正确的成员变量和成员方法。

---

### 13.2.2 Parcelable 方式

除了 Serializable 之外，使用 Parcelable 也可以实现相同的效果，不过不同于将对象进行序列化，Parcelable 方式的实现原理是将一个完整的对象进行分解，而分解后的每一部分都是 Intent 所支持的数据类型，这样也就实现传递对象的功能了。

下面我们来看一下 Parcelable 的实现方式，修改 Person 中的代码，



```java
public class Person implements Parcelable {
    private String name;
    private int age;
    
    public static final Creator<Person> CREATOR = new Creator<Person>() {
        @Override
        public Person createFromParcel(Parcel in) {
            Person person =new Person();
            person.name=in.readString();
            person.age=in.readInt();
            return person;
        }

        @Override
        public Person[] newArray(int size) {
            return new Person[size];
        }
    };

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(@NonNull Parcel dest, int flags) {
        dest.writeString(name);
        dest.writeInt(age);
    }
}
```

Parcelable 的实现方式要稍微复杂一些。可以看到，首先我们让 Person 类去实现了Parcelable 接口，这样就必须重写 describeContents()和 writeToParcel()这两个方法。其中describeContents()方法直接返回0就可以了，而 writeToParcel()方法中我们需要调用Parcel 的 writeXxx()方法，将 Person 类中的字段一一写出。注意，字符串型数据就调用writeString()方法，整型数据就调用 writeInt()方法，以此类推。

除此之外，我们还必须在 Person 类中提供一个名为 CREATOR 的常量，这里创建了Parcelable.Creator 接口的一个实现，并将泛型指定为Person。接着需要重写 createFromParcel()和newArray()这两个方法,在createFromParcel()方法中我们要去读取刚才写出的name 和age字段，并创建一个 Person 对象进行返回，其中 name 和age 都是调用 Parcel的readXxx()方法读取到的，**注意这里读取的顺序一定要和刚才写出的顺序完全相同**。而newArray()方法中的实现就简单多了，只需要 new出一个 Person 数组，并使用方法中传人的size作为数组大小就可以了。

接下来，在FirstActivty 中我们仍然可以使用相同的代码来传递 Person 对象，只不过在 SecondActivity 中获取对象的时候需要稍加改动，如下所示

`Person person = (Person) getIntent().getParcelableExtra("person data");`

注意,这里不再是调用getSerializableExtra()方法,而是调用getParcelableExtra()方法来获取传递过来的对象了，其他的地方都完全相同。

对比一下，**Serializable**的方式较为简单，但由于会把整个对象进行序列化，因此**效率会比 Parcelable 方式低一些**，所以在通常情况下还是更加推荐使用 Parcelable的方式来实现Intent传递对象的功能

## 13.3 定制自己的日志工具

早在第1章的 1.4节中我们就已经学过了 Android 日志工具的用法，并且日志工具也确实贯穿了我们整本书的学习，基本上每一章都有用到过。虽然 Android 中自带的日志工具功能非常强大，但也不能说是完全没有缺点，例如在打印日志的控制方面就做得不够好。

打个比方，你正在编写一个比较庞大的项目，期间为了方便调试，在代码的很多地方都打印了大量的日志。最近项目已经基本完成了，但是却有一个非常让人头疼的问题，之前用于调试的那些日志，在项目正式上线之后仍然会照常打印，这样不仅会降低程序的运行效率，还有可能将一些机密性的数据泄露出去.

那该怎么办呢?难道要一行一行地把所有打印日志的代码都删掉?显然这不是什么好点子不仅费时费力，而且以后你继续维护这个项目的时候可能还会需要这些日志。因此，最理想的情况是能够自由地控制日志的打印，当程序处于开发阶段时就让日志打印出来，当程序上线了之后就把日志屏蔽掉。

看起来好像是挺高级的一个功能，其实并不复杂，我们只需要定制一个自己的日志工具就可以轻松完成了。比如新建一个 Logutil 类，

```java
public class LogUtil {
    public static final int VERBOSE=1;
    public static final int DEBUG=2;
    public static final int INFO=3;
    public static final int WARN=4;
    public static final int ERROR=5;
    public static final int NOTHING=6;
    public static int level=VERBOSE;
    public static void v(String tag,String msg){
        if (level<=VERBOSE){
            Log.v(tag,msg);
        }
    }
    public static void d(String tag,String msg){
        if (level<=DEBUG){
            Log.d(tag,msg);
        }
    }
    public static void i(String tag,String msg){
        if (level<=INFO){
            Log.i(tag,msg);
        }
    }
    public static void w(String tag,String msg){
        if (level<=WARN){
            Log.w(tag,msg);
        }
    }
    public static void e(String tag,String msg){
        if (level<=ERROR){
            Log.e(tag,msg);
        }
    }
}
```

可以看到,我们在 LogUtil 中先是定义了 VERBOSE、DEBUG、INFO、WARN、ERROR、NOTHING这6个整型常量，并且它们对应的值都是递增的。然后又定义了一个静态变量 level，可以将它的值指定为上面6个常量中的任意一个。
接下来我们提供了 v()、d()、i()、w()、e()这 5 个自定义的日志方法，在其内部分别调用了Log.v()、Logd()、Log,i()、Log,w()、Loq.e()这5个方法来打印日志，只不过在这些自定义的方法中我们都加入了一个 if 判断，只有当level 的值小于或等于对应日志级别值的时候，才会将日志打印出来。

这样就把一个自定义的日志工具创建好了，之后在项目里我们可以像使用普通的日志工具一样使用 LogUtil，比如打印一行 DEBUG级别的日志就可以这样写:

`LogUtil.d("TAG"，"debug log");`

打印一行 WARN级别的日志就可以这样写:

`LogUtil.w("TAG"，“warn log");`

然后我们只需要修改 level 变量的值，就可以自由地控制日志的打印行为了。比如让 level等于 VERBOSE 就可以把所有的日志都打印出来，让level 等于 WARN 就可以只打印警告以上级别的日志，让Level 等于NOTHING 就可以把所有日志都屏蔽掉。

使用了这种方法之后，刚才所说的那个问题就不复存在了，你只需要在开发阶段将 Level指定成VERBOSE，当项目正式上线的时候将 Level 指定成NOTHING就可以了。

---

## 13.4 调试Android 程序

当开发过程中遇到一些奇怪的 bug，但又迟迟定位不出来原因是什么的时候，最好的解决办法就是调试了。调试允许我们逐行地执行代码，并可以实时观察内存中的数据，从而能够比较轻易地查出问题的原因。那么本节中我们就来学习一下使用Android Studio来调试Android程序的技巧。

调试工作的第一步肯定是添加断点，这里由于我们要调试登录部分的问题，所以断点可以加在登录按钮的点击事件里面。添加断点的方法也很简单，只需要在相应代码行的左边点击一下就可以了，然后就会出现一个红点，然后在点击调试按钮`debug app`。

这种调试方式虽然完全可以正常工作，但在调试模式下，程序的运行效率将会大大地降低.如果你的断点加在一个比较靠后的位置，需要执行很多的操作才能运行到这个断点，那么前面这些操作就都会有一些卡顿的感觉。没关系，Android 还提供了另外一种调试的方式，可以让程序随时进人到调试模式，下面我们就来尝试一下。

这次不需要选择调试模式来启动程序了，就使用正常的方式来启动程序。由于现在不是在调试模式下，程序的运行速度比较快，可以先把账号和密码输入好。然后点击 Android Studio顶部工具栏的 Attach debugger to Android process 按钮,这里目前只列出了一个进程，也就是我们当前程序的进程。选中这个进程，然后点击 OK 按就会让这个进程进入到调试模式了。

执行完前面的代码之后，然后在要调试的某一行代码中添加断点，接下来在程序中点击 Login（例子）按钮，Android Studio 同样也会自动打开 Debug 窗口，之后的流程就都是相同的了。相比起来，第二种调试方式会比第一种更加灵活，也更加常用。

---

## 13.5 创建定时任务

Android中的定时任务一般有两种实现方式，一种是使用Java API里提供的 Timer类，一种是使用Android的Alarm机制。这两种方式在多数情况下都能实现类似的效果，但 Timer有一个明显的短板，它并不太适用于那些需要长期在后台运行的定时任务。我们都知道，为了能让电池更加耐用，每种手机都会有自己的休眠策略，Android 手机就会在长时间不操作的情况下自动让CPU进入到睡眠状态，这就有可能导致 Timer 中的定时任务无法正常运行。而Alarm则具有唤醒CPU的功能，它可以保证在大多数情况下需要执行定时任务的时候 CPU都能正常工作。需要注意，这里 **唤醒 CPU** 和 **唤醒屏幕** 完全不是一个概念，千万不要产生混淆。

### 13.5.1 Alarm 机制

那么首先我们来看一下Alarm机制的用法吧，其实并不复杂，主要就是借助了AlarmManager类来实现的。这个类和 NotificationManager 有点类似，都是通过调用 Context 的 getSystemService()方法来获取实例的，只是这里需要传人的参数是 Context.ALARM_SERVICE。因此获取一个AlarmManager 的实例就可以写成:
AlarmManager manager = (AlarmManager) getSystemService(Context.ALARM_SERVICE);
接下来调用AlarmManager 的 set()方法就可以设置一个定时任务了，比如说想要设定一个任务在10秒钟后执行，就可以写成:

`long triggerAtTime = SystemClock.elapsedRealtime() + 10 *1000;`

`manager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP，triggerAtTime，pendingIntent);`

上面的两行代码你不一定能看得明白,因为 set()方法中需要传入的3个参数稍微有点复杂.下面我们就来仔细地分析一下。

* 第一个参数是一个整型参数，用于指定 AlarmManager 的工作类型有4种值可选分别是ELAPSED_REALTIME、ELAPSED_REALTIME_WAKEUP、RTC和RTC_WAKEUP.其中ELAPSED_REALTIME表示让定时任务的触发时间从系统开机开始算起,但不会唤醒CPU。ELAPSED_REALTIME_WAKEUP同样表示让定时任务的触发时间从系统开机开始算起，但会唤醒CPU。RTC表示让定时任务的触发时间从 1970年1月1日0点开始算起，但不会唤醒 CPU。RTC_WAKEUP 同样表示让定时任务的触发时间从1970年1月1日0点开始算起,但会唤醒CPU。
* 使用 SystemClock.elapsedRealtime()方法可以获取到系统开机至今所经历时间的毫秒数
* 使用System.currentTimeMillis()方法可以获取到1970年1月1日0点至今所经历时间的毫秒数。
* 然后看一下第二个参数，这个参数就好理解多了，就是定时任务触发的时间，以毫秒为单位。如果第一个参数使用的是ELAPSED_REALTIME 或ELAPSED_REALTIME_WAKEUP，则这里传人开机至今的时间再加上延迟执行的时间。如果第一个参数使用的是RTC或RTC_WAKEUP，则这里传入1970年1月1日0点至今的时间再加上延迟执行的时间.
* 第三个参数是一个 PendingIntent，对于它你应该已经不会陌生了吧。这里我们一般会调用getService()方法或者 getBroadcast()方法来获取一个能够执行服务或广播的 PendingIntent。这样当定时任务被触发的时候，服务的 onStartCommand()方法或广播接收器的onReceive()方法就可以得到执行。

了解了 set()方法的每个参数之后，你应该能想到，设定一个任务在 10 秒钟后执行也可以写成

`long triggerAtTime = System.currentTimeMillis() + 10 *1000;manager.set(AlarmManager.RTC_WAKEUP，triggerAtTime，pendingIntent);`

那么，如果我们要实现一个长时间在后台定时运行的服务该怎么做呢?其实很简单，首先新建一个普通的服务，比如把它起名叫 LongRunningService，然后将触发定时任务的代码写到onStartCommand()方法中，如下所示





---

## 13.6 多窗口模式编程

由于手机屏幕大小的限制，传统情况下一个手机只能同时打开一个应用程序，无论是Android、IOS还是 Windows Phone都是如此。我们也早就对此习以为常，认为这是理所当然的事情。而Android 7.0系统中却引入了一个非常有特色的功能-多窗口模式，它允许我们在同一个屏幕中同时打开两个应用程序。对于手机屏幕越来越大的今天，这个功能确实是越发重要了.

### 13.6.1 进入多窗口模式

首先你需要知道，我们不用编写任何额外的代码来让应用程序支持多窗口模式。事实上，本书中所编写的所有项目都是支持多窗口模式的。但是这并不意味着我们就不需要对多窗口模式进行学习，因为系统化地了解这些知识点才能编写出在多窗口模式下兼容性更好的程序。

